---
title: Estandares de desarrollo VOG
description: Estandares VOG para el desarrollo de extensiones.
lastUpdated: true
---

import { FileTree } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

## Introducción

La presente guía de estándares de desarrollo en AL para Virtual Office Group C.A. tiene como objetivo establecer un marco técnico unificado que garantice la calidad, escalabilidad y compatibilidad de nuestras soluciones dentro del ecosistema Microsoft Dynamics 365 Business Central. Al adoptar las directrices oficiales de Microsoft, nuestra organización asegura el desarrollo de extensiones **cloud-ready** que minimizan los conflictos técnicos y facilitan las actualizaciones continuas del sistema. Este compromiso con la excelencia en el código no solo optimiza el mantenimiento de nuestras aplicaciones, sino que también garantiza una experiencia de usuario coherente y profesional, alineada con las mejores prácticas globales de ingeniería de software.

## Lenguaje Tecnico

Se establece como norma obligatoria que la nomenclatura técnica dentro del código fuente se realice en **inglés**. Esta directriz abarca todos los elementos que componen la lógica y estructura de la extensión, incluyendo:

- *Identificadores de Objetos*: (**Tables**, **Pages**, **Codeunits**, **Reports**, **Enums**, **Queries**).

- *Identificadores de Campos*: Nombres de campos en tablas y extensiones de tablas.

- *Lógica de Programación*: Nombres de variables, constantes y métodos (procedimientos).

- *Arquitectura de Eventos*: Nombres de suscriptores y publicadores de eventos.

### Excepción: Capa de Usuario (UI)

La única excepción permitida para el uso del español dentro de los archivos **.al** será la propiedades (**Caption** y **ToolTip**) y las variables tipo **Label** declaradas.

<Aside type="caution">
    Sera uso del español en las propiedades (**Caption** y **ToolTip**) y las variables tipo **label**, siempre y cuando no se utilicen archivos de traducción externos. No obstante, para proyectos destinados a publicar en el AppSource, estas propiedades y variables deberán definirse inicialmente en inglés y localizarse mediante archivos **.xlf.**
</Aside>

### Excepción: Comentarios

Se permite el uso del español para los comentarios internos del código. A diferencia de la nomenclatura técnica (objetos, variables, métodos), que debe ser estrictamente en inglés, los comentarios tienen como fin la comunicación inmediata entre los desarrolladores del equipo.

## Estructura de la extensión

Para garantizar la mantenibilidad y uniformidad de los proyectos, toda extensión debe seguir una estructura de archivos organizada y jerárquica, evitando estructuras planas en proyectos de mediana o gran envergadura.

### Organización de la Raíz del Proyecto

El directorio raíz de la extensión debe contener los archivos de configuración y las carpetas principales de recursos:

`.alpackages/`: Carpeta de dependencias (símbolos).

`src/`: Directorio contenedor de todo el código fuente de la aplicación.

`test/`: Directorio dedicado exclusivamente a las unidades de prueba (Test Codeunits).

`app.json`: Archivo de manifiesto de la extensión (obligatorio).

`logo.jpg`: Imagen representativa de la extensión (formato 150x150 recomendado).

`README.md`: Documentación general del proyecto.

`.gitignore`: (**Obligatorio**) Define los archivos que Git debe ignorar. Debe excluir específicamente la carpeta .alpackages, los archivos de traducción generados (*.g.xlf) y los resultados de compilación (*.app).

`.vscode/`: Carpeta que contiene la configuración del entorno (ej. **launch.json** y **settings.json**).

`AppsourceCop.json`: Archivo de configuración para validaciones AppSourceCop (Obligatorio en las extensiones para el AppSource).


#### `Ejemplo`

<FileTree>

- .alpackages/
- .vscode/
  - launch.json
  - settings.json
- package.json
- src/
- test/
- logo.jpg
- app.json
- .gitignore
- README.md
- AppsourceCop.json

</FileTree>


<Aside>
    La estructura del proyecto vendra establecida como plantilla estandar desde Github al momento de iniciar un nuevo proyecto de desarrollo en AL.
</Aside>

### Estructura de la Carpeta /src (Agrupación Funcional)

Se prohíbe el uso de una estructura plana para el código fuente. Los objetos deben agruparse en subcarpetas dentro de `src/` basándose en su area de negocio. Una estructura estándar es:

#### Ejemplo 1

<FileTree>

- .alpackages/
- .vscode/
- src
  - Bank
    - Page
        - VOGBankCard.Page.al
        - VOGBankList.Page.al
    - Table
        - VOGBank.Table.al
    - PageExtension
        - VOGBankCard.PageExt.al
        - VOgBankList.PageExt.al
- test/
- logo.jpg
- app.json
- .gitignore
- README.md
- AppsourceCop.json

</FileTree>

#### Ejemplo 2

<FileTree>

- .alpackages/
- .vscode/
- src
  - OCR Document
    - Page
        - IncomingDocumetList.Page.al
        - IncomingDocumentDetail.Page.al
    - TableExtension
        - IncomingDocument.TableExt.al
    - Codeunit
        - OCRSend.Codeunit.al
- test/
- logo.jpg
- app.json
- .gitignore
- README.md
- AppsourceCop.json

</FileTree>

<Aside type="caution">
   Las carpetas y subcarpetas dentro de `src/` deben nombrarse en inglés y reflejar claramente la funcionalidad o el módulo al que pertenecen los objetos contenidos. Se debe utilizar la nomenclatura PascalCase para los nombres de las carpetas (por ejemplo, `SalesOrders`, `CustomerManagement`, `InventoryControl`).
</Aside>

## Nomenclatura de archivos

Cada nombre de archivo debe contener el prefijo establecido, nombre del objeto (usando solo los caracteres A-Z, a-z y 0-9), el tipo de objeto y la extensión del archivo.

### Ejemplo 

| Objetos Nuevos | Extensiones de objetos |
| --- | --- |
| `Vog<nombre>.<NombreDeObjecto>.al` | `Vog<nombre>.<NombreDeObjecto>Ext.al` |

<Aside type="caution">
   El prefijo `Vog` es obligatorio para todos los archivos de código fuente dentro de la extensión, asegurando una identificación clara y consistente de los objetos desarrollados por Virtual Office Group C.A.
</Aside>


Para el tipo de objeto en la nomenclatura del archivo, se deben utilizar las siguientes abreviaturas:

| Objetos | Abbreviación |
| --- | --- |
| Page | Page |
| Page Extension | PageExt |
| Page Customization | PageCust |
| Codeunit | Codeunit |
| Table | Table |
| Table Extension | TableExt |
| XML Port | Xmlport |
| Report | Report |
| Request Page | RequestPage |
| Query | Query |
| Enum | Enum |
| Enum Extension | EnumExt |
| Control Add-ins | ControlAddin |
| Dotnet | Dotnet |
| Profile | Profile |
| Interface | Interface |
| Permission Set | PermissionSet |
| Permission Set Extension | PermissionSetExt |

## Nombre de Objetos

En el caso de los objetos, estos ejemplos muestran cómo asignar un nombre a los archivos.

### Ejemplo

| Nombre del objeto | Nombre de archivo |
| --- | --- |
| codeunit 70000000 VOGSalesperson | `VogSalesPerson.Codeunit.al` |
| páge 70000000 VOGVendor | `VogVendor.Page.al` |
| pageextension 70000000 VOGSalesperson extends "Vendor Card" | `VogSalesperson.PageExt.al` |

<Aside type="caution">
  El nombre del objeto dentro del archivo de código AL debe coincidir exactamente con el nombre del archivo, excluyendo la extensión del archivo (.al).
</Aside>

## Formateo del codigo

- Utilice todas las letras minúsculas para las palabras clave del idioma reservado.
- Utilice cuatro espacios para la sangría.
- Los corchetes siempre deben comenzar en una nueva línea. Si solo hay una propiedad, se puede colocar en una sola línea.
- Escribir en PascalCase para nombres de objetos, variables y métodos.

### Ejemplo

```csharp
page 123 PageName
{
    actions
    {
        area(Processing)
        {
            action(ActionName)
            {
                trigger OnAction()
                begin
                end;
            }
        }
    }

    var
        VogTempCustomer: Record Customer temporary;

    [EventSubscriber(ObjectType::Page, Page::"Item Card", 'OnAfterGetCurrRecordEvent', '', false, false)]
    local procedure OnOpenItemCard(var rec: Record Item)
    var
        OnRecord: Option " ", Item, Contact;
    begin
        EnablePictureAnalyzerNotification(rec."No.", OnRecord::Item);
    end;
}
```

## Estructura de Objetos

Dentro de un archivo de código `.al`, la estructura de todos los objetos debe seguir la secuencia:

1. Propiedades
2. Las construcciones específicas del objeto, como
    - Campos de tabla
    - Diseño de página
    - Acciones
    - Desencadenantes
3. Variables globales
    - Etiquetas
    - Variables globales
4. Métodos

## Nomenclatura de campos en tablas

- Todas los campos deben utilizar el prefijo `Vog`.
- Una campo debe comenzar con una letra mayúscula.
- Se deben omitir los espacios en blanco, los puntos y otros caracteres (como paréntesis) que harían necesarias las comillas alrededor de una variable.
- Si un campo es un compuesto de dos o más palabras o abreviaturas, cada palabra o abreviatura debe comenzar con una letra mayúscula

### Ejemplo

```csharp
table 50100 VogOfficeRoom
{
    DataClassification = CustomerContent;

    fields
    {
        field(1;VogRoomName; Text[100])
        {
            DataClassification = CustomerContent;
            
            trigger OnValidate()
            begin
                // Lógica de validación si fuera necesaria
            end;
        }

        field(2;VogCapacity; Integer)
        {
            DataClassification = CustomerContent;
            MinValue = 1;
            BlankZero = true;
        }
    }
}
```

## Nomenclatura de variables

- Todas las variables globales o protegidas deben utilizar el prefijo `Vog`. Se exceptuan las variables locales dentro de los métodos u procedimientos. 
- Las variables que hacen referencia a un objeto AL deben contener el nombre del objeto, abreviado cuando sea necesario.
- Una variable debe comenzar con una letra mayúscula.
- Se deben omitir los espacios en blanco, los puntos y otros caracteres (como paréntesis) que harían necesarias las comillas alrededor de una variable.
- Si una variable es un compuesto de dos o más palabras o abreviaturas, cada palabra o abreviatura debe comenzar con una letra mayúscula

### Ejemplo 1 

```csharp
VogWIPBuffer: Record "Job WIP Buffer"
```

### Ejemplo 2

```csharp
VogPostline: Codeunit "Gen. Jnl.-Post Line";
VogGenJnlPostLine: Codeunit "Gen. Jnl.-Post Line";
```

### Ejemplo 3

```csharp
VogAmountLCY: Decimal; 
``` 

## Declaración de método o procedimientos

Para declarar un método:

- Todas las variables deben utilizar el prefijo `Vog`.
- Incluir un espacio después de un punto y coma al declarar varios argumentos.
- El punto y coma se puede utilizar al final del end
- Los métodos deben nombrarse usando PascalCase, como las variables.
- Debe haber una línea en blanco entre las declaraciones de método

```csharp
local procedure VogMyProcedure(Customer: Record Customer; Int: Integer)
begin
end;

// Blank line between methods

local procedure VogMyProcedure2(Customer: Record Customer; Int: Integer)
begin
end;
```

## Métodos de llamada

Al llamar a un método, incluya un espacio después de cada comando si va a pasar varios parámetros. Los paréntesis deben especificarse cuando se realiza una llamada al método o al sistema, como: 

```csharp
VogMyProcedure();
VogMyProcedure(1);
VogMyProcedure(1, 2); 
```

## Declaración de publicador de eventos (EventPublisher)

para declarar un publicador de eventos:

- Todo evento debe estar precedido por el atributo `[IntegrationEvent(false, false)]`
- Los eventos deben declararse como local procedure a menos que se requiera acceso desde fuera del objeto.
- El cuerpo del procedimiento debe estar siempre vacío (begin end;). No se permite lógica dentro de un publisher.
- La nomenclatura debe comenzar con el prefijo `Vog` seguido de una descripción del evento que se está publicando. La descripcion debe indicar el momento en que se produce el evento. Ejemplo: `VogOnBeforeValidateCustomerNo`, `VogOnAfterInsertSalesHeader`, etc.



### Ejemplo

```csharp

codeunit 50105 VogBookingEvents
{
    // Este publicador se ejecuta cuando se valida el número de cliente en una cabecera de ventas
    [EventPublisher(ObjectType::Table, Database::"Sales Header", 'OnAfterValidateEvent', 'Sell-to Customer No.', false, false)]
    procedure VogOnAfterValidateSellToCustomerNo(var Rec: Record "Sales Header"; var xRec: Record "Sales Header")
    begin
    end;
}

```

## Declaración de suscriptor de eventos (EventSubscriber) 

Para declara un suscriptor de eventos:

- Nombrar con el prefijo `Vog` seguido de una descripción del evento al que se está suscribiendo.
- Los procedimientos de eventos deben ser locales (local procedure). No hay razón para que otra Codeunit llame manualmente a un suscriptor de eventos.

### Ejemplo


```
codeunit 50105 VogBookingEvents
{
    // Este suscriptor se ejecuta cuando se valida el número de cliente en una cabecera de ventas
    [EventSubscriber(ObjectType::Table, Database::"Sales Header", 'OnAfterValidateEvent', 'Sell-to Customer No.', false, false)]
    local procedure VogOnAfterValidateSellToCustomerNo(var Rec: Record "Sales Header"; var xRec: Record "Sales Header")
    var
        OfficeMgt: Codeunit VogOfficeManagement;
    begin
        // La lógica debe estar encapsulada o llamar a otros métodos para mantener el suscriptor limpio
        if Rec."Sell-to Customer No." <> '' then
            OfficeMgt.CheckCustomerOfficeAvailability(Rec."Sell-to Customer No.");
    end;
}
```

## Permisos

Los permisos en AL permiten a los usuarios dar permiso a otros usuarios en función de sus necesidades particulares.


<Aside type="caution">
   Los permisos deben definirse en la estructura raiz de la extensión, asegurando que los usuarios tengan los accesos adecuados según las funcionalidades implementadas.   
</Aside>

### Tipos de Permisos

| Valores de Permisos | Representacion | Descripción |
| --- | --- | --- |
| R o r | Leer | **R** para letura directa, **r** para acceso de lectura indirecta. |
| I o i | Insertar | **I** para permiso de insercion directa, **i** para permiso de insercion indirecta. |
| M o m | Modificar | **M** para permiso de modificacion directa, **m** para permiso de modificacion indirecta. |
| D o d | Eliminar | **D** para permiso de eliminacion directa, **d** para permiso de eliminacion indirecta. |
| X or x  | Execute (Run) | X para ejecutar permisos directamente, x para permisos de ejecucion indirecta. |

![Ejemplo de permisos](../../../../assets/guide/permissions.webp)

<Aside type="note">
   En versiones anteriores los permisos debian ser declarados en el archivo PermissionSet o PermissionSetExtension, dependiendo de si se esta creando un nuevo conjunto de permisos o extendiendo uno existente. En version actuales de Business Central, los permisos pueden ser definidos directamente en un archivo xml dentro de la estructura raiz de la extension.
</Aside>

## Clasificacion de campos con DataClassification

Debido a los requisitos de las leyes y normativas de privacidad, los campos de la clase de campo deben usar la propiedad DataClassification y su valor debe ser diferente de *ToBeClassified*. Esto se aplica a los campos de las tablas y las extensiones de tabla.

En la tabla siguiente se describen los niveles de confidencialidad de datos que se pueden asignar.

| Sensibilidad | Descripción |
| --- | --- |
| AccountData | Información de facturación del cliente e información del instrumento de pago, incluida la información de contacto del administrador, como el nombre, la dirección o el número de teléfono del administrador del inquilino. |
| CustomerContent | Contenido proporcionado o creado directamente por administradores y usuarios. El valor predeterminado es |
| SystemMetadata | Datos generados mientras se ejecuta el servicio o programa que no se pueden vincular a un usuario o inquilino. |
| EndUserIdentifiableInformation | (EUII) Datos que identifican o podrían utilizarse para identificar al usuario de un servicio de Microsoft. EUII no incluye contenido del Cliente. |
| EndUserPseudonymousIdentifiers | (EUPI) Un identificador creado por Microsoft y vinculado al usuario de un servicio de Microsoft. Al combinarse con otra información, como una tabla de mapeo, EUPI identifica al usuario final. EUPI no contiene información cargada ni creada por el cliente (contenido del cliente o EUII). |


## Uso de ApplicationArea

Las páginas, los controles, las acciones y los campos no aparecerán en Dynamics 365 Business Central si no se ha establecido.

**Se aplica a:**

- Page Label
- Page Field
- Page Part
- Page System Part
- Page Chart Part
- Page Action
- Page Custom Action
- Page File Upload Action
- Page User Control
- Page
- Report

### Tipo de Valores

| Valores | Descripcion |
| --- | --- |
| All | Se va a aplicar a todas las versiones |
| Basic | Solo se Aplica a la version basica de business central |
| Suite | Solo se Aplica a la version premium de business central |

![Ejemplo uso de ApplicationArea](../../../../assets/guide/applicationArea.webp)


<Aside type='note' title='Nota'>La extension no se instala en produccion sin que todos los campos tenga un ApplicationArea configurado.</Aside>

## Uso de UsageCategory

Para Habilitar la busqueda a traves de Dynamics 365 Busines Central de debe declarar el uso de la propiedad **UsageCaterory**

Para Habilitar la busqueda a traves de Dynamics 365 Busines Central de debe declarar el uso de la propiedad **UsageCaterory**

| Valores | Descripcion |
| --- | --- |
| **None** | La página, el informe o la consulta no se incluyen en una búsqueda. |
| **Lists** | La pagina, el informa o la consulta se enumeran como **Listas**, en la categoria **Paginas y Tareas** |
| **Tasks** | La pagina, el informa o la consulta aparecen como **Tareas**, en la categoria **Paginas y Tareas** |
| **ReportsAndAnalysis** | La pagina, el informa o la consulta aparecen como **Informes**, en la categoria **Informes y analisis** |
| **Documents** | La pagina, el informa o la consulta aparecen como **Informes y analisis**, en la categoria **Informes y analisis** |
| **History** | La pagina, el informe o la consulta aparecen como **Archivo en la categoria Informes y analisis** |
| **Administration** | La consulta aparece como **Administracion** en la categoria **Pagina y tareas** |

## Paginas de API

Las páginas de API son diferentes de las páginas de interfaz de usuario. Requieren diferentes propiedades y no se comportan de la misma manera. Dado que las páginas de API se utilizan para la integración con aplicaciones externas, deben tratarse como contratos. Para lograr esto, los siguientes temas son importantes.

- Aplicación de API independiente
- Propiedades de la página
- Control de versiones
- Propiedades de campo
- Campos predeterminadoS

Es una buena práctica desarrollar páginas de API en una aplicación independiente en lugar de combinarlas en una solución. Al hacerlo, proporciona una mejor capacidad de mantenimiento y es una buena manera de separar las preocupaciones

Las propiedades que se deben definir son:

### APIPublisher

El nombre del editor de la API suele ser la empresa que crea la API. Es la primera parte personalizada de la dirección URL de un punto de conexión determinado. El valor no distingue entre mayúsculas y minúsculas.

```csharp
APIPublisher = 'contoso';
```

### APIGroup

Establece el grupo del punto de conexión de la API en el que se expone la página o la consulta. En la dirección URL, APIGroup viene después de APIPublisher. Se puede usar para distinguir diferentes aplicaciones de API o grupos de API entre sí. El valor no distingue entre mayúsculas y minúsculas.

```csharp
APIGroup = 'app1';
```

### APIVersion

Establece las versiones del punto de conexión de la API en el que se expone la página o la consulta. Esta propiedad no es obligatoria. Si no se especifica, las API se expondrán como versión 'beta'.

La APIVersion se puede establecer en 'beta' o tener el formato 'vx.y'. Ejemplo:

```csharp
APIVersion = 'beta';
```

### Múltiples versiones de API

**Nunca** debe romper las versiones existentes. Cualquier cambio importante requiere la creación de una nueva versión.

Es posible exponer una API en varias versiones:

```csharp
    APIVersion = 'beta', 'v1.0';
```

Esto permite publicar una nueva versión de una aplicación API sin copiar todos los objetos individuales y actualizar los números de versión. Solo es necesario copiar los objetos de API que se modifican en una nueva versión. Los demás objetos solo necesitan una adición a la propiedad APIVersion para estar disponibles en el punto de conexión de la nueva versión

### EntitySetName

EntitySetName es el nombre de la entidad en plural. Piense en ello como el nombre de la colección de entidades. Se recomienda utilizar camelCasing para esta propiedad. ¡El valor distingue entre mayúsculas y minúsculas!

```csharp
EntitySetName = 'itemCategories';
```

### EntityName (Nombre de la entidad)

EntityName establece el nombre de entidad singular para la página o consulta de la API. Este nombre no se utiliza en la URL. En su lugar, se usa EntityName en la información de metadatos. Se recomienda utilizar camelCasing para esta propiedad.

```csharp
EntityName = 'itemCategory';
```

### DelayedInsert

Esta propiedad es necesaria en una página de API editable. No se aplica a un objeto de consulta de API. Si se establece en la página de la API, DelayedInsert no es necesario. Todas las páginas de API aplican el comportamiento para especificar primero todos los valores de campo y, a continuación, insertar el registro a la vez.`Editable = false`

```csharp
DelayedInsert = true;
```

### Ejemplo Completo

```csharp
PageType = API;
APIPublisher = 'contoso';
APIGroup = 'app1';
APIVersion = 'v1.0';
EntitySetName = 'itemCategories';
EntityName = 'itemCategory';
DelayedInsert = true;
```

### Propiedades de campo

La estructura base de una página de API es similar a una página de lista de interfaz de usuario

```csharp
layout
{
		area(Content)
		{
			repeater(records)
			{
			...
			}
    }
}
```

Al especificar los campos, hay que tener en cuenta algunas consideraciones.

- No hay propiedades obligatorias. La propiedad no desempeña ningún papel en las páginas de la API, por lo que se puede omitir.
- La propiedad también es opcional y solo se debe usar en caso de que la aplicación externa requiera subtítulos y el título debe ser diferente del título estándar.
- El nombre del campo, debe definirse en camelCasing. No puede contener espacios, puntos u otros caracteres especiales

### Campos obligatorios

- SystemId
    - **Este campo debe exponerse con el nombre id**
- SystemModifiedAt
    - Este campo debe exponerse con el nombre . Si eliges un nombre diferente, la funcionalidad del webhook no funcionará correctamente.

```csharp
layout
{
    area(Content)
    {
        repeater(records)
        {
            field(id; Rec.SystemId) { }
            field(lastModifiedDateTime; Rec.SystemModifiedAt) { }
        }
    }
}
```

## Uso de Begin.. End

Solo use begin.. end para encerrar instrucciones compuestas

### Ejemplo

```csharp
if FindSet() then begin
    repeat
        ...
    until next() = 0;
end;

```

```csharp
if FindSet() then
    repeat
        ...
    until next() = 0;
```

Codigo Correcto

```csharp
// xcepcion del caso
if X then begin
    if Y then 
        //Hacer Algo
end else 
    (not X)
```

No utilice líneas en blanco:

- al principio o al final de cualquier función (después y antes de `begin end`)
- dentro de la expresión multilínea
- después de las líneas en blanco


## Espaciado de comentarios

Comience siempre los comentarios con // seguido de un carácter de espacio

### Ejemplo

```csharp
RowNo += 1000; //Move way below the budget  
```

```csharp
RowNo += 1000; // Move way below the budget
```

## Espaciado de CASE

Una acción CASE debe comenzar en una línea después de la posibilidad.

### Ejemplo

```csharp
case Letter of
        'A': Letter2 := '10';
        'B': Letter2 := '11';
  end;
```

```csharp
case Letterof
        'A':
            Letter2:= '10';
        'B':
            Letter2:= '11';end;
```

## Orden de las declaraciones de variables

Las declaraciones de variables deben ordenarse por tipo. En general, los tipos de objetos y variables complejas se enumeran primero, seguidos de las variables simples. El orden debe ser:

- Record
- Report
- Codeunit
- XmlPort
- Page
- Query
- Notification
- BigText
- DateFormula
- RecordId
- RecordRef
- FieldRef
- FilterPageBuilder


```csharp
 StartingDateFilter: Text;
    Vendor: Record Vendor;

    //Incorrecto
```

```csharp
 Vendor: Record Vendor;
  StartingDateFilter: Text;

  //Correcto
```

## Verdadero/falso innecesario

No utilice palabras clave o innecesariamente si la expresión ya es una expresión lógica.`true / false`

### Ejemplo 1

```csharp
if IsPositive() = true then //Incorrecto
```

```csharp
if IsPositive() then //Correcto
```

### Ejemplo 2


```csharp

if Complete <> true then //Incorrecto
```

```csharp
 if not Complete then //Correcto
```

## Invocaciones de objectos con nombre

Al llamar a un objeto de forma estática, utilice el nombre del objeto, no el identificador del objeto

### Ejemplo

```csharp
  Page.RunModal(525, SalesShptLine); //Incorrecto
```

```csharp
 Page.RunModal(Page::"Posted Sales Shipment Lines", SalesShptLine); //Correcto
```

## Uso de la propiedad SetLoadFileds

Para el rendimiento del código, es importante que utilice SetLoadFields tanto como sea posible.

Si desea recuperar un registro de la base de datos para comprobar si el registro está disponible, utilice siempre SetLoadFields en los campos de clave principal de la tabla, de modo que solo se recuperen esos campos de la base de datos.

### Ejemplo

```csharp
if not Item.Get(ItemNo) then  //Incorrecto
    exit();
```

```csharp
Item.SetLoadFields("No.");
if not Item.Get(ItemNo) then //Correcto
    exit();
```

<Aside type="caution">
   El uso de SetLoadFields se utilizara para optimizar el rendimiento de las consultas a la base de datos, asegurando que solo se recuperen los campos necesarios para la operación en cuestión. Esto es especialmente importante en entornos con grandes volúmenes de datos, donde la eficiencia en el acceso a la información puede tener un impacto significativo en el rendimiento general de la aplicación.
</Aside>

## Uso de ReadIsolation en consultas de lecturas

Al realizar operaciones de lectura en registros, es fundamental utilizar la propiedad ReadIsolation para garantizar la consistencia y la integridad de los datos. Esta práctica ayuda a evitar problemas relacionados con lecturas sucias o inconsistentes, especialmente en entornos concurrentes donde múltiples procesos pueden acceder y modificar los mismos datos simultáneamente.

Se debe utilizar ReadIsolation siempre que se realice una lectura de datos que no tenga intención de modificar registros inmediatamente.

### Niveles de Aislamiento Permitidos

| Nivel de Aislamiento | Descripción | Casos de Uso Recomendados |
| --- | --- | --- |
| Default  |	 El sistema utiliza el aislamiento por defecto de Business Central (generalmente ReadCommitted). |	Consultas estándar sin requisitos especiales. |
| ReadCommitted |	 Garantiza que la transacción solo lea datos que han sido confirmados (commit). Evita "lecturas sucias". |	Operaciones financieras o contables donde la precisión es obligatoria. |
| ReadUncommitted |	El nivel más permisivo. No emite bloqueos compartidos y no respeta bloqueos exclusivos. Puede leer datos modificados pero no confirmados. |	Dashboards, Estadísticas y Reports. Ideal para contar registros disponibles sin bloquear el procesos. |
| RepeatableRead |	Asegura que si se lee un registro dos veces en la misma transacción, los datos serán iguales. Bloquea los registros leídos. |	Procesos de validación complejos donde los datos no deben cambiar durante el cálculo. |
| UpdLock |	Lee el registro y coloca un bloqueo de actualización inmediato. Ninguna otra transacción puede obtener un bloqueo de actualización o exclusivo.	Prevención de condiciones de carrera. | Úsalo antes de un Modify para asegurar que nadie toque el registro mientras lo procesas. |

### Ejemplo 1

```
// Estándar para consultas de solo lectura (Reporting/Dashboards)
procedure VogGetTotalAvailableRooms(): Integer
var
    OfficeRoom: Record "VOF Office Room";
begin
    // Evita bloqueos en la tabla mientras otros usuarios modifican
    OfficeRoom.ReadIsolation := IsolationLevel::ReadUncommitted;
    OfficeRoom.SetRange(Status, OfficeRoom.Status::Available);
    exit(OfficeRoom.Count());
end;

```

### Ejemplo 2

```
// Estándar para preparación de actualización
procedure VogMarkRoomAsOccupied(RoomNo: Code[20])
var
    OfficeRoom: Record "VOF Office Room";
begin
    // Bloquea el registro específicamente para esta transacción
    OfficeRoom.ReadIsolation := IsolationLevel::UpdLock;
    if OfficeRoom.Get(RoomNo) then begin
        OfficeRoom.Status := OfficeRoom.Status::Occupied;
        OfficeRoom.Modify(true);
    end;
end;

```

## Uso del lockTable en la modificación de registros

El método LockTable debe utilizarse para asegurar que los datos no cambien entre el momento en que se leen y el momento en que se modifican. Su uso debe ser cuidadoso y seguir el principio de "bloquear lo más tarde posible".

Debe seguir los siguientes lineamientos al utilizar LockTable:

- Siempre debe llamarse antes de la función de lectura (Get, Find, FindFirst). Si se llama después de leer, el bloqueo no garantiza que los datos leídos sigan siendo los mismos.
- El bloqueo dura hasta que la transacción termina. Por ello, se prohíbe poner un LockTable al inicio de un proceso largo si no es estrictamente necesario.
- No usar LockTable en tablas maestras (como Customer o Item) a menos que sea estrictamente necesario, ya que detiene el trabajo de todos los usuarios de la empresa.
- Nunca mostrar un Confirm o un Error largo después de un LockTable. La tabla quedará bloqueada para el resto de la empresa.
- Antes de usar LockTable, considera si puedes usar `ReadIsolation := IsolationLevel::UpdLock`, que es más moderno y preciso.

```
// Estándar para actualización de estado de oficina
procedure VogFinalizeVofReservation(RoomNo: Code[20])
var
    OfficeRoom: Record VogOfficeRoom;
begin
    // 1. Declarar el bloqueo antes de la lectura
    OfficeRoom.LockTable(); 
    
    // 2. Obtener el registro (ahora bloqueado para otros)
    if OfficeRoom.Get(RoomNo) then begin
        // 3. Lógica de modificación
        OfficeRoom.Status := OfficeRoom.Status::Occupied;
        OfficeRoom.Modify(true);
    end;
    // El bloqueo se libera automáticamente al terminar el método (End)
end;


```

## Evitar el uso innecesario de CalcFields

El método CalcFields puede ser costoso en términos de rendimiento, especialmente si se utiliza en grandes conjuntos de datos o dentro de bucles. Por ello, su uso debe ser limitado a situaciones donde sea absolutamente necesario calcular campos específicos.

El estándar moderno exige sustituirlo por técnicas de carga anticipada.

Se deben seguir las siguientes directrices:

- Utilice `SetLoadFields` para especificar qué campos calculados se deben cargar antes de realizar una operación de lectura masiva (FindSet). Esto reduce la cantidad de llamadas a la base de datos.
- Si un campo calculado se consulta con demasiada frecuencia y afecta al rendimiento, se debe evaluar convertirlo en un campo físico que se actualice mediante lógica de eventos (reduciendo la carga de cálculo en tiempo real).
- Está estrictamente prohibido usar CalcFields dentro de un bucle repeat until. En su lugar, carga los campos necesarios fuera del bucle.

### Ejemplo 1: Uso innecesario de CalcFields

```csharp
// Realiza múltiples llamadas a SQL por cada registro
if OfficeRoom.FindSet() then
    repeat
        OfficeRoom.CalcFields(VogOccupancy Rate); // Llamada extra por cada iteración
        TotalRate += OfficeRoom.VogOccupancyRate;
    until OfficeRoom.Next() = 0;   
```

### Ejemplo 2: Uso recomendado con SetLoadFields

```csharp
// Optimiza la lectura en una sola consulta SQL
OfficeRoom.SetLoadFields(VogOccupancyRate,VogRoomName); 
if OfficeRoom.FindSet() then
    repeat
        // El campo ya está cargado en memoria desde el FindSet
        TotalRate += OfficeRoom.VogOccupancyRate;
    until OfficeRoom.Next() = 0;
```